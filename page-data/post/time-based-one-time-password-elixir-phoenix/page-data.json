{"componentChunkName":"component---src-templates-blog-post-js","path":"/post/time-based-one-time-password-elixir-phoenix/","result":{"data":{"markdownRemark":{"html":"<h2>What is TOTP?</h2>\n<p>Those who have enabled multi-factor authentication (mfa) in his/her Google accounts, major vendors out there are aware of the importance of having them. For others, who are not aware of\nwhat mfa is and how it works, please look into the following wiki link: <a style=\"text-decoration: none;\" href=\"https://en.wikipedia.org/wiki/Time-based_One-time_Password_algorithm\" target=\"_blank\">TOTP Wiki Page</a></p>\n<h3>Traditional Approach of TOTP apps:</h3>\n<p>Most of the Authenticator apps out there, starts providing One Time Password easily, when you:</p>\n<ul>\n<li>scan the QR code provided to you</li>\n<li>Enter the secret text provided to you</li>\n</ul>\n<h3>Why this might not be the completely safest approach?</h3>\n<p>There is <strong>no way to tell whether the rightful owner is scanning the QR code or using the key</strong>, which makes it a bit vulnerable. I'm not arguing about it's existence, but the mere fact that what if someone gets hold of my secret key and password, they can easily generate the OTPs and get access to my systems. Many, people might say that we need to start using Password Generators for this purpose, I'm in fact, voting in favor of them. The next thing that I'm about share might sound silly, but has worked well for many of my clients and users.</p>\n<h3>A small step can improve the situation a little bit better:</h3>\n<ul>\n<li>Instead of the sending the encoded secret key as QR code to email or account, just <strong>generate a custom url from the application with an expirable token of considerable time and convert that URL to QR code and share it with the users.</strong></li>\n<li>The expirable token can be used only within the <strong>time limit</strong> and it makes the identity clear, when checked in the application side</li>\n<li>The <strong>Authenticator app</strong> needs to have a <strong>particular user-agent or some kind of signature header to differentiate the requests from the app</strong></li>\n<li>The above step makes sure that no other people can get access to TOTP secret key.</li>\n<li>The Authenticator App needs to scan and hit the URL with the distinguished mark to get the TOTP secret key.</li>\n</ul>\n<p>The above mentioned steps are just <strong>suggestions</strong> for those who feel the necessity of implementing your own MFA solution and are in need to monitor or track the access usage safely.</p>","frontmatter":{"title":"Taking MFA to next level - A new approach!","date":"12 December, 2019","tags":["elixir","phoenix","mfa","one-time-password","totp"]},"excerpt":"What is TOTP? Those who have enabled multi-factor authentication (mfa) in his/her Google accounts, major vendors out there are aware of theâ€¦"}},"pageContext":{"slug":"/time-based-one-time-password-elixir-phoenix/","prev":{"fields":{"slug":"/elixir-shell-recompile-noop-issue/"},"frontmatter":{"published":true}},"next":{"fields":{"slug":"/xmpp-mongooseim-ejabberd-erlang-journey-part-1/"},"frontmatter":{"published":true}}}},"staticQueryHashes":["63159454"]}