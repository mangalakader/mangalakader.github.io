{"componentChunkName":"component---src-templates-blog-post-js","path":"/post/download-binaries-using-httpoison-elixir-the-correct-way/","result":{"data":{"markdownRemark":{"html":"<p class=\"text-justify\">There are tons of methods for organising binaries into a particular project in different programming languages. But, I am writing this method particularly to illustrate the pure usage of elixir and joy of learning it! This tutorial is for intermediate users with enough experience in using elixir. I hope you enjoy it!</p>\n## How can you leverage it?\nIt could be anyone of the following:\n- a `mix` task\n- a `genserver`\n- a `function`\n- a `escript` etc.,\n<p>In my particular use case, I wanted a mix task, so I will be illustrating the use case with Mix Tasks. Feel free to try and explore different options.</p>\n<h2>Mix Task:</h2>\n<p>We all would have started using mix tasks, the moment we installed elixir in our system. The basic mix task that helped me my elixir journey is <code>mix help</code>. The first thing that I wanted to learn is how to create a simple mix task. I am not going to ellaborate on how to write a mix task, but rather focus on the main functionality.</p>\n<h2>Requirements:</h2>\n<ul>\n<li>Erlang ~> 20</li>\n<li>Elixir ~> 1.6</li>\n<li>A simple elixir project (create it using <code>mix new</code>)</li>\n<li>Create a basic mix task (<a href=\"https://medium.com/defmethod-works/writing-mix-tasks-for-fun-and-profit-61dd609e7263\">Reference</a>)</li>\n</ul>\n<h1>Getting Started</h1>\n<pre><code class=\"language-elixir\"># Your example mix task should be like the one below\ndefmodule Mix.Tasks.Hello do\n  @shortdoc ~S(\"Example mix task for showing hello world\")\n  \n  use Mix.Task\n  def run(_) do\n  #################\n  Code hidden......\n  #################\n  end\nend\n</code></pre>\n<p>Add <code>{:httpoison, \"~> 1.3\"}</code> to your new sample project's <code>deps</code> in <code>mix.exs</code>. You can get to know the latest version of HTTpoison using <code>mix hex.info httpoison</code>.</p>\n<h1>Writing a Basic Download Service using HTTPoison</h1>\n<p>First of all you need to know how much would it take for the download to complete. As we are not creating something competing to wget, curl or even IDM / XDM, I will keep it very simple, I am going to download something small with a timeout of 5 minutes, so that my task will wait for 5 minutes for the download to complete.</p>\n<ul>\n<li>A dummy download link</li>\n<li>Timeout: 5 minutes (5 * 60 * 1000)</li>\n</ul>\n<p>With the above things ready, we are nearly ready to get into coding. Make sure to either keep the download url in config or use the <code>OptionsParser</code> in Elixir.</p>\n<pre><code class=\"language-elixir\">def download(url, path) do\n  {:ok, file} = File.open(\"path/filename\", [:write, :exclusive])\n    ...to continue\nend\n</code></pre>\n<p>One main thing to remember is that, since it is a mix task, you are supposed to start HTTpoison before starting the download. If you are writing a mix application, just starting HTTPoison in the <code>mix.exs</code> is enough.</p>\n<pre><code class=\"language-elixir\">def download(url, path) do\n  HTTPoison.start() #Mandatory if you are using it in a mix task\n  {:ok, file} = File.open(\"path/filename\", [:write, :exclusive])\nend\n</code></pre>\n<h1>Using HTTPoison get</h1>\n<pre><code class=\"language-elixir\">HTTPoison.get(url, [\"Accept\": \"application/octet-stream\"], [follow_redirect: true, stream_to: self(), recv_timeout: 5 * 60 * 1000])\n</code></pre>\n<p>When you just need to hit an endpoint, the syntax is as simple as <code>HTTPoison.get(url, [])</code> but since, we want to download, I am using the necessary headers and <code>follow_redirect</code> is optional because, some sites redirect you to cloud storage services, where you will get the file and you can also control, you redirection limit. The <code>stream_to</code> is the interesting part, which is the thing that let's us download without blocking the IO. So, the above command gives a tuple in the form <code>{:ok, %HTTPoison.AsyncResponse{id: ref}}</code>. The tuple contains a reference to the downloading process.</p>\n<p>Now the code will look like the following:</p>\n<pre><code class=\"language-elixir\">def download(url, path) do\n  HTTPoison.start()\n  {:ok, file} = File.open(\"path/filename\", [:write, :exclusive])\n  with {:ok, %HTTPoison.AsyncResponse{id: ref}} &#x3C;- HTTPoison.get(url, [\"Accept\": \"application/octet-stream\"],\n                [follow_redirect: true, stream_to: self(), recv_timeout: 5 * 60 * 1000]) do\n    write_data(ref, file, path)\n  else\n    error ->\n      File.close(file)\n      File.rm_rf!(\"path/filename\")\n  end\nend\n</code></pre>\n<h1>Further steps</h1>\n<p>The HTTPoison provides certain structs to understand the response from the server it hits and provides easier interface to interpret each type of struct and consume them.</p>\n<p><code>alias HTTPoison.{AsyncHeaders, AsyncRedirect, AsyncResponse, AsyncStatus, AsyncChunk, AysncEnd}</code></p>\n<p>The above aliases and our function in the previous snippet <code>write_data(ref, file, path)</code> are closely related.</p>\n<pre><code class=\"language-elixir\">defp write_data(ref, file, path) do\n  receive do\n    %AsyncStatus{code: 200} ->\n      write(ref, file, path)\n    %AsyncStatus{code: error_code} ->\n      File.close(file)\n    %AsyncRedirect{headers: headers, to: to, id: ^ref} ->\n      download(to, path)\n    %AsyncChunk{chunk: chunk, id: ^ref} ->\n      IO.binwrite(file, chunk)\n      write(ref, file, path)\n    %AsyncEnd{id: ^ref} ->\n      File.close(file)\n  end\nend\n</code></pre>\n<p>The <code>write_data</code> is just a <code>receive do</code> loop with pattern matching. </p>\n<ul>\n<li>first pattern checks for connection success code <code>200</code> and then it again sends to the same function</li>\n<li>the next, it checks for codes other than success and closes the file if it is executed</li>\n<li>the redirect pattern, checks for any redirects and get the redirect url and starts the download with the new URL</li>\n<li>the chunk is the real hero of the day, which accumulates our downloaded data in chunks and writes to the specified file</li>\n<li>the end indicates the completion of streaming from the process.</li>\n</ul>\n<h1>Finally our download task is ready</h1>\n<pre><code class=\"language-elixir\">defmodule Mix.Tasks.Hello do\n  @shortdoc ~S(\"Example mix task for showing hello world\")\n  use Mix.Task\n  alias HTTPoison.{AsyncHeaders, AsyncRedirect, AsyncResponse, AsyncStatus, AsyncChunk, AysncEnd}\n  def run(_) do\n  download(\"#{URL}\", \"#{SAVE_TO_PATH}\")\n  end\n  def download(url, path) do\n    HTTPoison.start()\n    {:ok, file} = File.open(\"path/filename\", [:write, :exclusive])\n    with {:ok, %HTTPoison.AsyncResponse{id: ref}} &#x3C;- HTTPoison.get(url, [\"Accept\": \"application/octet-stream\"],\n                  [follow_redirect: true, stream_to: self(), recv_timeout: 5 * 60 * 1000]) do\n      write_data(ref, file, path)\n    else\n      error ->\n        File.close(file)\n        File.rm_rf!(\"path/filename\")\n    end\n  end\n  defp write_data(ref, file, path) do\n    receive do\n      %AsyncStatus{code: 200} ->\n        write(ref, file, path)\n      %AsyncStatus{code: error_code} ->\n        File.close(file)\n      %AsyncRedirect{headers: headers, to: to, id: ^ref} ->\n        download(to, path)\n      %AsyncChunk{chunk: chunk, id: ^ref} ->\n        IO.binwrite(file, chunk)\n        write(ref, file, path)\n      %AsyncEnd{id: ^ref} ->\n        File.close(file)\n    end\n  end\nend\n</code></pre>\n<p>This is our basic downloader and is ready for use. Please, keep in mind the above code is not production ready, and don't put system critical uses using the above sample code, but it is usable after some mission critical tweaks. All the best!</p>","frontmatter":{"title":"Download Project Binaries using HTTPoison - Elixir","date":"08 September, 2018","tags":["elixir","erlang","functional programming"]},"excerpt":"In my particular use case, I wanted a mix task, so I will be illustrating the use case with Mix Tasks. Feel free to try and exploreâ€¦"}},"pageContext":{"slug":"/download-binaries-using-httpoison-elixir-the-correct-way/","prev":{"fields":{"slug":"/add-yourself-to-sudoers/"},"frontmatter":{"published":true}},"next":{"fields":{"slug":"/elixir-shell-recompile-noop-issue/"},"frontmatter":{"published":true}}}},"staticQueryHashes":["63159454"]}